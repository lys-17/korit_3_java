### Review

◎ Method
- 순차적으로 실행되는 여러 코드들을 하나의 이름으로 묶어둔 것

call1() ~ call4() 매개변수늬 유무 / return 유무로 분할한 유형으로 학습함

- 형식

        (접근지정자) 리턴타입 메서드명(매개변수1, 매개변수2) { 
        메서드에 순서대로 틀어갈 코드
        }

- 정의 예시
```java
public void writeSchedule(String date, String content) {
  System.out.println(date + "일의 스케줄은 다음과 같습니다");
  System.out.println(content);
}
```
- 호출 예시

같은 클래스 내에 정의된 메서드라면(지금과 같은 상황)

      writeSchedule("20250321", "메서드/오버로딩/클래스/복습")

◎ 클래스 - 설계도 / 틀 / 청사진

클래스 내부에는 속성(필드/ 멤버변수 / 인스턴스 변수) / 행위(메서드)

- 생성자 정의
→ 원래 기본 생성자는 default로 있음

◎ Constructor(생성자)
- 객체자 생성될 때 호출되는 특별한 메서드

특징
1) 클래스명과 생성자명은 같음
2) 기본 생성자 / 매개변수 생성자
  - 기본 생성자 - 정의하지 않아도 default로 있지만, 생성자를 하나라도 정의하는 순간 기본 생성자도 적어야함
  - 매개변수 생성자 - 객체를 생성할 때 필수적으로 요구되어지는 속성을 명시한 생성자
3) return이 없음. call1()이거나 call2()이거나
4) 형식

   a. 기본 생성자
     - 클래스명() {}
   
   b. 매개변수 생성자
     - 클래스명(매개변수1, 매개변수2) {
            this.매개변수1 = 매개변수1;
            this.매개변수2 = 매개변수2;
       }

생성 방법
1) 일일이 타이핑하기
2) 햄버거 → code → generate 하기
3) alt + ins 하기

◎ Getter / Setter

객체명.속성명 = 속성값; 의 형태로 여태까지 속성값을 대입하거나 바꾸는 것이 가능했음

그래서 예를 들어 batteryTime에 음수를 집어넣더라도, 자료형이 int 이기 때문에 속성값을 논리적으로는 불가능하더라도 대입하는 것이 가능했음. 이는 컴퓨터가 자료형만 맞아 떨어진다면 그대로 받아들인다고 볼 수 있음

즉, 악의적으로 클래스 외부에서 데이터를 조작하는 것도 가능하다는 의미가됨. 그래서 이와 같은 문제를 막기 위해

다른 클래스에서 직접적으로 속성값을 바꾸는 것을 막고, 특정 method 를 경유해야만 속성값을 대입할 수 있도록 처리하는 것이 Getter / Setter 및 접근지정자의 개념임

1. Setter : 속성값을 대입(변경)하기 위한 method를 통칭하고 set+속성명으로 이루어져 있음

  ex) setBatteryTime()
    a. call2() 유형
    b. 내부에 로직을 작성하여 필드의 논리적인 개념에 맞지 않는 데이터를 걸러낼 수 있음
  
2. Getter