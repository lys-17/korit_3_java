# 인터페이스(interface)
- Java에서 클래스가 구현해야하는 '메서드들'의 집합을 정의하는 일종의 규약(protocol)


- 인터페이스는 메서드의 시그니처(메서드 이름, 리턴 타입, 매개변수 목록) 만을 포함하며, 메서드의 실제 구현은 포함하지 않음

→ 추상 메서드와 유사한 점

- 다중 상속을 지원
  → 이를 통해 클래스가 여러 인터페이스를 구현할 수 있음
    - 추상 클래스는 단일 상속을 지원해서 상속 과정을 알아보기 쉬움. 바로 어제 수업했는데 얘는 다중 상속을 지원해서 편하다고함.

## 특징
1. 추상 메서드 : 인터페이스 내의 모든 메서드들은 기본적으로 추상 메서드
2. 상수 : 인터페이스 내에서 선언된 변수는 모두 '자동으로'  public static final 상수로 취급됨.
3. 다중 상속 - 클래스는 여러 인터페이스를 구현할 수 있음.

## 추상 클래스와의 공통점
- 모든 추상 메서드를 포함할 수 있고, 이를 서브 클래스에서 구현해야 함
- 
## 추상 클래스와의 차이점
- 추상 클래스
  1. 부분 구현 허용 : 추상 클래스는 추산 메서드 뿐만 아니라 일반 메서드도 포함할 수 있음
  2. 상태 저장 가능 : 추상 클래스는 인스턴스 변수(속성/ 필드)를 가질 수 있음
  3. 단일 상속 : 클래스는 하나의 추상 클래스만 상속받을 수 있음
  4. 생성자 : 추상 클래스는 생성자를 가질 수 있음
  5. 다양한 접근 지정자(access modifier) : 추상 클래스의 메서드와 변수는 다양한 접근 지정자를 가질 수 있음
  

- 인터페이스
  1. 완전한 추상화 : 인터페이스는 기본적으로 모든 메서드가 추상 메서드(Java8 이후에 defualt / static 메서드를 사용 가능하긴 함)
  2. 인터페이스는 인스턴스 변수 (필드 중 객체마다 닶이 다른 변수)를 가질 수 없고, 상수만 선언 가능
  3. 다중 상속 : 클래스는 여러 인터페이스를 '구현할 수 있음'
  4. 생성자 없음 : 인터페이스는 생성자를 가질 수 없음 → 일단 필드에서 객체마다 다른 값을 지닐 수 없기 때문에 생성자 생성이 불가능
  5. 자동 public : 인터페이스의 메서드들은 자동으로 public이며, 메서드 선언에 접근 지정자를 명시할 필요 x. 근데 또 Java 이후에 default / static 메서드가 있긴 함

```java
package ch13_abstraction.interfaces;

public class TvRemoteController {
    private PowerButton powerButton;
    private ChannelDownButton channelDownButton;
    private ChannelUpButton channelUpButton;

    public TvRemoteController(PowerButton powerButton, ChannelDownButton channelDownButton, ChannelUpButton channelUpButton) {
        this.powerButton = powerButton;
        this.channelDownButton = channelDownButton;
        this.channelUpButton = channelUpButton;
    }
}

package ch13_abstraction.interfaces;

public class Main {
    public static void main(String[] args) {
        TvRemoteController tvRemoteController = new TvRemoteController();
    }
}
```
그래서 tvRemoteController 객체를 생성하기 위해서 new TvRemoteController(이 안의 argument를 어떻게 작성할 것인가);

```java
String hello1 = "안녕하세요";
String hello2 = new String("안녕하세요");
```
String의 경우 class라는 것을 이제는 알 수 있음 그래서 hello1 / hello2 는 사실은 변수명이 아니라 객체명이라고 수업을 했었음

```java
Student student1 = new Student("홍길동", "의적");
```
일 때 사실 '홍길동'/'의적'은 객체였다는 것을 추측할 수 있음. 또한 객체 생성을 할 때 생성자의 argument로 객체가 들어갈 수 있다는 사실도 방금 알게 됨

배열을 예시로 들었을 때 arr = {1,2,3,4,5} 에서 1의 변수명이 없는 것처럼 → 하지만 arr[0]으로 위치를 지시할 수 있는 것처럼 객ㅊ체가 있긴 하지만 객체명이 없을 수 있다는 점을 이해하는 게 매우 중요함

names = { "김영", "김일", "김이", "김삼" }

---

interfaces 참고

1. VolumeDownButton 클래스 생성
2. extends Button 적용 → 빨간 거 뜸 → 이유(추상 메서드 때문)
3. 추상 메서드의 method body(구현부) 작성
4. 따로 override의 필요성 alt+ins → 얘는 추상 메서드가 아니기 때문에 없다고 해서 빨간 줄이 안 떴음
5. onDown 메서드를 오버라이드 → 음량을 계속 내림
6. VolumeUpButton 클래스를 정의하고 2-5에 해당하는 버전을 작성해주셔야 함. 다 끝나고 나면 
7. TvRemoteController 클래스로 감
8. 필드에 private VolumeDownButton volumeDownButton; 을 추가해주면 → 생성자도  AllArgsConstructor가 되어야 하기 때문
9. 그냥 다 지웠다가 alt + ins로 다시 만드는게 편함
10. 그렇게 하면 Main에서 에러가 남 → 생성자를 volumeDownButton을 추가해놨는데 Main에서 반영이 안돼있어서
11. 추가해 주고 TvRemoteController 클래스로 돌아가서
12. 메서드 가지고 오기
13. 다음과 같이 메서드 추가하기
```java
    public void onPressedVolumeDownButton() {
    volumeDownButton.onPressed();
}

public void onDownVolumeDownButton() {
    volumeDownButton.onDown();
}
```
14. Main으로 넘어가서 실행
---

## 정리
이상의 프로세스를 중심으로 VolumeUpButton 클래스를 정의하고 메서드도 정의하고 TvRemoteController에 필드 추가하고 또 메서드 정의하고 Main에 객체 생성 방식을 수정하고 메서드를 호출하면 완료

용어 중심 정리 

추상 메서드 

추상 클래스 

인터페이스 

단일 상속 

다중 상속 

추상 클래스 vs 인터페이스 공통점

  - 클래스의 필드에 객체가 들어갈 수 있다는 점.
  - 그것이 Main 단계에서 객체 생성 방식에 어떤 차이가 생기는지.
  - 그리고 필드에 객체가 들어가 있을 때, 특정 객체의 메서드를 사용하는 방법


---
interfaces / Notification 참고
